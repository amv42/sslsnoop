

idea :

use http://www.hsc.fr/ressources/breves/passe-partout.html.fr  to get keys
use http://pauldotcom.com/2010/10/tsharkwireshark-ssl-decryption.html  
 or http://www.rtfm.com/ssldump/ to read streams
use scapy, because it's fun ?

use python.


State:
------
somewhat works .

  $ sudo python openssh.py `pgrep ssh`

Outputs :

WARNING: No route found for IPv6 destination :: (no default route?)
INFO:sslsnoop.openssh:Target has pid 16697
INFO:root:Attach process 16697
INFO:root:Attach <PtraceProcess #16697> to debugger
INFO:root:Set <PtraceProcess #16697> options to 1
INFO:sslsnoop.openssh:looking for struct session_state
INFO:abouchet:found instance @ 0xb8d32268
INFO:root:Quit debugger
INFO:sslsnoop.openssh:Active state ciphers : <SessionCiphers RECEIVE: 'aes128-ctr/hmac-md5' SEND: 'aes128-ctr/hmac-md5' > at 0xb8d32268
INFO:sslsnoop.openssh:Please make some ssh  traffic
u n a m e   - a v
Linux ssh1.90.ha.ovh.net 2.6.32.7-mutu-grs-ipv4-32 #2 SMP Sat Feb 6 13:33:23 UTC 2010 i686 GNU/Linux

poc done.
It often doesn't work out and it surely doesn't work on output streams af of release c6e0011

Biblio
-------

Bringing volatility to Linux
http://dfsforensics.blogspot.com/2011/03/bringing-linux-support-to-volatility.html

Extracting truecrypt keys from memory
http://jessekornblum.com/tools/volatility/cryptoscan.py

python-ptrace ( hey, haypo again)
https://bitbucket.org/haypo/python-ptrace/wiki/Home
https://bitbucket.org/haypo/python-ptrace/wiki/Documentation

from ptrace.debugger.memory_mapping import readProcessMappings


abouchet.py is passe-partout.py - OK - 04/03/2011

next ssh :
Keys are cleaned from memory (ssh.c:830) after ssh_login (ssh_connect.c:1097).

ssh_login:
--------------
keys are read
Key exchange is initiated (ssh_connect.c:1121) ssh_kex2 (ssh_connect2.c:105)
-> session_id2 is created
ssh_userauth2 is initiated (ssh_connect.c:1122) (ssh_connect2.c:360)
end

ssh_userauth2:
--------------
client ask server for AUTH (ssh_connect2.c:370)
server says ok, go on (ssh_connect2.c:372)
client use dispatch_run to get password or passphrase (ssh_connect2.c:414)

in packet.c, struct session_state is the struct we want to target.
there is 
 packet.c:197:static struct session_state *active_state, *backup_state;
and defautl allocation never changed after that:
 packet.c:206:s->max_packet_size = 32768;

ssh_userauth2:
--------------
packet_start // use active_state
packet_put_cstring("ssh-userauth"); // memcpy
packet_send();   ////  packet_send2 packet.c:960
debug("SSH2_MSG_SERVICE_REQUEST sent");
packet_write_wait();  -> packet goes out
type = packet_read();
[..]
packet_check_eom()
[..]
pubkey_prepare(&authctxt);
userauth_none(&authctxt);
[..]
dispatch_init(&input_userauth_error);
dispatch_set(SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);
dispatch_set(SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);
dispatch_set(SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);
dispatch_run(DISPATCH_BLOCK, &authctxt.success, &authctxt);	/* loop until success */
[..]
pubkey_cleanup(&authctxt);
dispatch_range(SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);


packet_send(2) packet.c:960
------------
if active_state->rekeying , alors, rien ne sort si ce n'est les SSH2_KEX_INIT
sending is done by packet.c:839:packet_send2_wrapped(void)

packet.c:839:packet_send2_wrapped(void)
-----------------------------------------
Encryption, Mac and Compression are done regarding to 	active_state->newkeys[MODE_OUT]->* values
MODE_OUT ( enum == 1 je crois)
active_state->outgoing_packet is compressed if required ( packet.c:866 )
padding/random is added if necessary (packet.c:889)
then MAC is calculated (packet.c:924)
then buffer is encrypted with 	
  cipher_crypt(&active_state->send_context, cp, (packet.c:933)   ->OpenSSL EVP_Cipher (evp/enc_min.c:348:int EVP_Cipher)
MAC is appended unencrypted
finally session is updated with seqnum++ and stuff like that
and set_newkeys is called if it's was a rekey command
[ packet is reading in active_state->output and will be sent by subsequent packet_write_wait]


packet.c:728:set_newkeys
------------------------
cipher_cleanup -> call OpenSSL cipher_cleanup
mac_clear() -> 
free data struct for enc, mac and comp ( IV & key )
kex.c:538:kex_get_newkeys(int mode)  -> use prepared memory current_keys[mode] struct  (NULLs the pointer for reprocessiong)
cipher_init
set &active_state->max_blocks_out

WHERE ARE THE KEY:
-----------------
&active_state->newkeys[mode]->enc
enc->name
enc->key
enc->iv
&active_state->receive_context.evp->app_data

and they must be in OpenSSL format... EVP in CypherContext struct

HOW TO READ:
------------
packet.c:1139
	/* Decrypt data to incoming_packet. */
	buffer_clear(&active_state->incoming_packet);
	cp = buffer_append_space(&active_state->incoming_packet, padded_len);
	cipher_crypt(&active_state->receive_context, cp,
	    buffer_ptr(&active_state->input), padded_len);

Data structs are the same size...
----------------
Next step, load a valid session_state 
print its address
ptrace it .

print CipherContext.cipher.name .

ok working 08/03/2011

NEXT :

use paramiko packet.py to decrypt packet.
 -> use a wrapper socket class around scapy for reading network streams into paramiko ( OK)
   => use scapy to get a stream ( sniff)
   => use scapy in a thread (OK)

openssh clientloop, packet.c:1120 
c'est newkeys qui contiens les cles....
bon. aller. on va loadMembers les array de pointers :) DONE

3 instances de 'p':
DEBUG:sslsnoop.openssh:IN: FB F9 3D DC 6D 05 13 C1 0F C7 53 20 30 93 78 89    ..=.m.....S 0.x.
DEBUG:sslsnoop.openssh:IN: BD F9 3D DC 6D 05 13 C1 0F C7 53 20 30 93 78 89    ..=.m.....S 0.x.
DEBUG:sslsnoop.openssh:IN: CA F9 3D DC 6D 05 13 C1 0F C7 53 20 30 93 78 89    ..=.m.....S 0.x.
'q':
DEBUG:sslsnoop.openssh:IN: AE F9 3D DC 6D 05 13 C1 0F C7 53 20 30 93 78 89    ..=.m.....S 0.x.

retry

from ssh
plain:     0000 0000 005e 0000 0000 0000 0001 70
encrypted: (send1)
5d78 2a52 79f7 929d bf34 f860 70ee 1230
3be1 7bb4 5127 6ed8 5884 2393 797b 71a2
3394 babe d290 b61f 3e88 296b 138f 4da6

read_poll enc/full: (aftr dec header but before dec rest)
c861 c37e cc5f 91a3 dd69 515e 5f6f 36f6
4683 7394 3774 37d9 11f3 2f97 c185 06d9

read/plain[94]:
0000 0000 0000 0001 70


DEBUG:socket.scapy:in: encrypted
91 c5 07 80 26 d4 44 21 d9 95 8f 77 dc 69 e5 79    ....&.d!...w.i.y
c8 61 c3 7e cc 5f 91 a3 dd 69 51 5e 5f 6f 36 f6    .a.~._...iq^_o6.
46 83 73 94 37 74 37 d9 11 f3 2f 97 c1 85 06 d9    f.s.7t7.../.....

DEBUG:sslsnoop.openssh:IN: plain
98 F1 DC 47 11 54 20 0D 9C F3 EF 23 16 4F 41 F3    ...G.T ....#.OA.


def hexify(data):
  s=''
  for i in range(0,len(data)):
    s+="%02x"% ord(data[i])
    if i%16==15:
      s+="\r\n"
    elif i%2==1:
      s+=" "
  s+="\r\n"
  print s


From TCPDUMP
from soscapy:
cf2e 0acf cbb8 3332 6165 3631 9059 4b4a
3698 8d9c 72c0 455f 2e96 4100 2dd0 fe8f
291a 8f65 e47b 30a9 0086 cd4f 0575 c0ea


le counter aes ne change pas dans le client
"aes_counter": "'\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x00\x00\x1e6\xf6\xbb'"
le notre passe a 
"aes_counter": "'\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x00\x00\x1e6\xf6\xbc'"


INFO:abouchet:found instance @ 0xb7dcd268
but
context instance at 0xb7dcd274

we have the old session_state pointer. damn.

app_data is @0xb920a138

scapy:
7592 acce 64c6 8bb5 dbc0 8621 9d14 57e9
c247 0d67 641c 1127 4649 0f03 a919 f6ed
c173 a37f bc50 dfac 6bcc 6eee 612f 9b1a

encypted:
3df2 95ad e52f 6fa0 3367 7acc 8338 fd21
5a51 e14b 9aad 3c54 31fd a3de 2fca e7e8
ddee 1ba8 064a 62e2 6512 226a 6f4a 11f4







