

idea :

use http://www.hsc.fr/ressources/breves/passe-partout.html.fr  to get keys
use http://pauldotcom.com/2010/10/tsharkwireshark-ssl-decryption.html  
 or http://www.rtfm.com/ssldump/ to read streams
use scapy, because it's fun ? but we need IP reassembly . 
pynids could be more useful...
dsniff is now in python ?
flowgrep

use python.


State:
------
somewhat works . Doesn't work on loopback. because scapy/python truncate loopback traffic to 1600 bytes.

  $ sudo python openssh.py `pgrep ssh`
  $ sudo python openssh.py `pgrep ssh` --server # for sshd

Outputs :

WARNING: No route found for IPv6 destination :: (no default route?)
INFO:sslsnoop.openssh:Target has pid 16697
INFO:root:Attach process 16697
INFO:root:Attach <PtraceProcess #16697> to debugger
INFO:root:Set <PtraceProcess #16697> options to 1
INFO:sslsnoop.openssh:looking for struct session_state
INFO:abouchet:found instance @ 0xb8d32268
INFO:root:Quit debugger
INFO:sslsnoop.openssh:Active state ciphers : <SessionCiphers RECEIVE: 'aes128-ctr/hmac-md5' SEND: 'aes128-ctr/hmac-md5' > at 0xb8d32268
INFO:sslsnoop.openssh:Please make some ssh  traffic
u n a m e   - a v
Linux ssh1.90.ha.ovh.net 2.6.32.7-mutu-grs-ipv4-32 #2 SMP Sat Feb 6 13:33:23 UTC 2010 i686 GNU/Linux

EOF

Other tricks :
--------------
* search ssh-agent for keys. (passe-partout style)

  $ sudo python openssl.py 27477 # ssh-agent
INFO:abouchet:Target has pid 27477
INFO:root:Attach process 27477
INFO:root:Attach <PtraceProcess #27477> to debugger
INFO:root:Set <PtraceProcess #27477> options to 1
INFO:abouchet:found instance <class 'ctypes_openssl.RSA'> @ 0xb835c9a0
INFO:abouchet:[X] Key saved to file outputs/id_rsa-2.key
INFO:abouchet:found instance <class 'ctypes_openssl.DSA'> @ 0xb835b4e8
INFO:abouchet:[X] Key saved to file outputs/id_dsa-2.key
INFO:abouchet:done for pid 27477

* search traditionnal running programs for keys. 

  $ sudo python finder.py
WARNING: No route found for IPv6 destination :: (no default route?)
INFO:finder:Searching in ssh-agent/1373 memory
INFO:root:Attach process 1373
WARNING:finder:ssh-agent/1373 not ptraceable
INFO:finder:Searching in ssh/20676 memory
INFO:root:Attach process 20676
INFO:root:Attach <PtraceProcess #20676> to debugger
INFO:root:Set <PtraceProcess #20676> options to 1
WARNING:abouchet:Restricting search to heap.
INFO:abouchet:found instance <class 'ctypes_openssh.session_state'> @ 0xb7acd268
INFO:sslsnoop.openssh:Active state ciphers : <SessionCiphers RECEIVE: 'aes128-ctr/hmac-md5' SEND: 'aes128-ctr/hmac-md5' > at 0xb7acd268
INFO:sslsnoop.openssh:[X] SSH session_state saved to file outputs/session_state-1.20676
INFO:finder:None
INFO:finder:Searching in ssh-agent/27477 memory
INFO:root:Attach process 27477
INFO:root:Attach <PtraceProcess #27477> to debugger
INFO:root:Set <PtraceProcess #27477> options to 1
WARNING:abouchet:Restricting search to heap.
INFO:abouchet:found instance <class 'ctypes_openssl.RSA'> @ 0xb835c9a0
INFO:abouchet:[X] Key saved to file outputs/id_rsa-6.key
WARNING:abouchet:Restricting search to heap.
INFO:abouchet:found instance <class 'ctypes_openssl.DSA'> @ 0xb835b4e8
INFO:abouchet:[X] Key saved to file outputs/id_dsa-6.key
INFO:finder:None


poc done.


Biblio
-------

Bringing volatility to Linux
http://dfsforensics.blogspot.com/2011/03/bringing-linux-support-to-volatility.html

Extracting truecrypt keys from memory
http://jessekornblum.com/tools/volatility/cryptoscan.py

python-ptrace ( hey, haypo again)
https://bitbucket.org/haypo/python-ptrace/wiki/Home
https://bitbucket.org/haypo/python-ptrace/wiki/Documentation

from ptrace.debugger.memory_mapping import readProcessMappings


abouchet.py is passe-partout.py - OK - 04/03/2011

next ssh :
Keys are cleaned from memory (ssh.c:830) after ssh_login (ssh_connect.c:1097).

ssh_login:
--------------
keys are read
Key exchange is initiated (ssh_connect.c:1121) ssh_kex2 (ssh_connect2.c:105)
-> session_id2 is created
ssh_userauth2 is initiated (ssh_connect.c:1122) (ssh_connect2.c:360)
end

ssh_userauth2:
--------------
client ask server for AUTH (ssh_connect2.c:370)
server says ok, go on (ssh_connect2.c:372)
client use dispatch_run to get password or passphrase (ssh_connect2.c:414)

in packet.c, struct session_state is the struct we want to target.
there is 
 packet.c:197:static struct session_state *active_state, *backup_state;
and defautl allocation never changed after that:
 packet.c:206:s->max_packet_size = 32768;

ssh_userauth2:
--------------
packet_start // use active_state
packet_put_cstring("ssh-userauth"); // memcpy
packet_send();   ////  packet_send2 packet.c:960
debug("SSH2_MSG_SERVICE_REQUEST sent");
packet_write_wait();  -> packet goes out
type = packet_read();
[..]
packet_check_eom()
[..]
pubkey_prepare(&authctxt);
userauth_none(&authctxt);
[..]
dispatch_init(&input_userauth_error);
dispatch_set(SSH2_MSG_USERAUTH_SUCCESS, &input_userauth_success);
dispatch_set(SSH2_MSG_USERAUTH_FAILURE, &input_userauth_failure);
dispatch_set(SSH2_MSG_USERAUTH_BANNER, &input_userauth_banner);
dispatch_run(DISPATCH_BLOCK, &authctxt.success, &authctxt);	/* loop until success */
[..]
pubkey_cleanup(&authctxt);
dispatch_range(SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);


packet_send(2) packet.c:960
------------
if active_state->rekeying , alors, rien ne sort si ce n'est les SSH2_KEX_INIT
sending is done by packet.c:839:packet_send2_wrapped(void)

packet.c:839:packet_send2_wrapped(void)
-----------------------------------------
Encryption, Mac and Compression are done regarding to 	active_state->newkeys[MODE_OUT]->* values
MODE_OUT ( enum == 1 je crois)
active_state->outgoing_packet is compressed if required ( packet.c:866 )
padding/random is added if necessary (packet.c:889)
then MAC is calculated (packet.c:924)
then buffer is encrypted with 	
  cipher_crypt(&active_state->send_context, cp, (packet.c:933)   ->OpenSSL EVP_Cipher (evp/enc_min.c:348:int EVP_Cipher)
MAC is appended unencrypted
finally session is updated with seqnum++ and stuff like that
and set_newkeys is called if it's was a rekey command
[ packet is reading in active_state->output and will be sent by subsequent packet_write_wait]


packet.c:728:set_newkeys
------------------------
cipher_cleanup -> call OpenSSL cipher_cleanup
mac_clear() -> 
free data struct for enc, mac and comp ( IV & key )
kex.c:538:kex_get_newkeys(int mode)  -> use prepared memory current_keys[mode] struct  (NULLs the pointer for reprocessiong)
cipher_init
set &active_state->max_blocks_out

WHERE ARE THE KEY:
-----------------
&active_state->newkeys[mode]->enc
enc->name
enc->key
enc->iv
&active_state->receive_context.evp->app_data

and they must be in OpenSSL format... EVP in CypherContext struct

HOW TO READ:
------------
packet.c:1139
	/* Decrypt data to incoming_packet. */
	buffer_clear(&active_state->incoming_packet);
	cp = buffer_append_space(&active_state->incoming_packet, padded_len);
	cipher_crypt(&active_state->receive_context, cp,
	    buffer_ptr(&active_state->input), padded_len);

Data structs are the same size...
----------------
Next step, load a valid session_state 
print its address
ptrace it .

print CipherContext.cipher.name .

ok working 08/03/2011

NEXT :

use paramiko packet.py to decrypt packet.
 -> use a wrapper socket class around scapy for reading network streams into paramiko ( OK)
   => use scapy to get a stream ( sniff)
   => use scapy in a thread (OK)

openssh clientloop, packet.c:1120 
c'est newkeys qui contiens les cles....
bon. aller. on va loadMembers les array de pointers :) DONE

3 instances de 'p':
DEBUG:sslsnoop.openssh:IN: FB F9 3D DC 6D 05 13 C1 0F C7 53 20 30 93 78 89    ..=.m.....S 0.x.
DEBUG:sslsnoop.openssh:IN: BD F9 3D DC 6D 05 13 C1 0F C7 53 20 30 93 78 89    ..=.m.....S 0.x.
DEBUG:sslsnoop.openssh:IN: CA F9 3D DC 6D 05 13 C1 0F C7 53 20 30 93 78 89    ..=.m.....S 0.x.
'q':
DEBUG:sslsnoop.openssh:IN: AE F9 3D DC 6D 05 13 C1 0F C7 53 20 30 93 78 89    ..=.m.....S 0.x.

retry

from ssh
plain:     0000 0000 005e 0000 0000 0000 0001 70
encrypted: (send1)
5d78 2a52 79f7 929d bf34 f860 70ee 1230
3be1 7bb4 5127 6ed8 5884 2393 797b 71a2
3394 babe d290 b61f 3e88 296b 138f 4da6

read_poll enc/full: (aftr dec header but before dec rest)
c861 c37e cc5f 91a3 dd69 515e 5f6f 36f6
4683 7394 3774 37d9 11f3 2f97 c185 06d9

read/plain[94]:
0000 0000 0000 0001 70


DEBUG:socket.scapy:in: encrypted
91 c5 07 80 26 d4 44 21 d9 95 8f 77 dc 69 e5 79    ....&.d!...w.i.y
c8 61 c3 7e cc 5f 91 a3 dd 69 51 5e 5f 6f 36 f6    .a.~._...iq^_o6.
46 83 73 94 37 74 37 d9 11 f3 2f 97 c1 85 06 d9    f.s.7t7.../.....

DEBUG:sslsnoop.openssh:IN: plain
98 F1 DC 47 11 54 20 0D 9C F3 EF 23 16 4F 41 F3    ...G.T ....#.OA.


def hexify(data):
  s=''
  for i in range(0,len(data)):
    s+="%02x"% ord(data[i])
    if i%16==15:
      s+="\r\n"
    elif i%2==1:
      s+=" "
  s+="\r\n"
  print s


From TCPDUMP
from soscapy:
cf2e 0acf cbb8 3332 6165 3631 9059 4b4a
3698 8d9c 72c0 455f 2e96 4100 2dd0 fe8f
291a 8f65 e47b 30a9 0086 cd4f 0575 c0ea


le counter aes ne change pas dans le client
"aes_counter": "'\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x00\x00\x1e6\xf6\xbb'"
le notre passe a 
"aes_counter": "'\x00\x00\x00\x00\x00\x00\x00\x00\n\x00\x00\x00\x1e6\xf6\xbc'"


INFO:abouchet:found instance @ 0xb7dcd268
but
context instance at 0xb7dcd274

we have the old session_state pointer. damn.

app_data is @0xb920a138

scapy:
7592 acce 64c6 8bb5 dbc0 8621 9d14 57e9
c247 0d67 641c 1127 4649 0f03 a919 f6ed
c173 a37f bc50 dfac 6bcc 6eee 612f 9b1a

encypted:
3df2 95ad e52f 6fa0 3367 7acc 8338 fd21
5a51 e14b 9aad 3c54 31fd a3de 2fca e7e8
ddee 1ba8 064a 62e2 6512 226a 6f4a 11f4

on sshd :
-------------------------
So there is the main root process, the root child and the unprivileged child.
root      7569  0.0  0.0   5644  2200 pts/2    S+   09:21   0:00 /home/jal/Compil/sslsnoop/biblio/openssh-5.5p1/sshd -D
root      7572  0.0  0.0   8932  3104 ?        Ss   09:21   0:00 sshd: jal [priv]                                         
jal       7655  0.0  0.0   8932  1416 ?        S    09:21   0:00 sshd: jal@pts/7   

Funny, forking give identical mappings. ??

UNPRIVILEGED CHILD - APP_DATA IS HERE - no active_session found
$ sudo python abouchet.py --string refresh 7655 ctypes_openssh.ssh_aes_ctr_ctx 0xb8595970
INFO:root:Attach process 7655
INFO:root:Attach <PtraceProcess #7655> to debugger
INFO:root:Set <PtraceProcess #7655> options to 1
INFO:abouchet:found instance <class 'ctypes_openssh.ssh_aes_ctr_ctx'> @ 0xb8595970
(  # <ctypes_openssh.ssh_aes_ctr_ctx object at 0xb743c104>
"aes_ctx": {             # <ctypes_openssl.AES_KEY object at 0xb743c1dc>
        "rd_key": b'A3&`"\x1d8\xe4*t\xc7\x91F\xcc\tNnim`LtU\x84f\x00\x92\x15 \xcc\x9b[W\xde&v\x1b\xaas\xf2}\xaa\xe1\xe7]fz\xbc2\x92\x15\xa8)8fZT\x92\x87\xbd\t\xf4\xfd\x01N\x93\xaa\xf4g\xab\xcc\xae39K\x13:\xcd\xb6\x12\x87\x13\x17\xaa\xe0\xb8\xdb\x04\xd3\x81\x90\x17\xe9L&\x05\xec\r>}\x0c\xb5\xe5y\xdf4un6xSk\x93\x08\x82\xd0\x9f\xbdg\xa9@\x89\x12\xc7v\xf1A\xac\x020#\xd3\x9d\x8dDz\xdd\x04V\xbd\xab\xf5\x17\x11\x80R\xc58\x1d\xdf\x81B\xc0\xdb\xd7\xffk.\xc0\xee\xa8-\xf4\xb4\xb5\xf2u\xf6u)\xa2\t\x1e\x07b\xe7i\xa1w0\xc1\xe4\x91I@,N.\xc2.\xcb\x0c\x9f\x13\xc9\xb6\x9c\xf3\xa37\x9e\x14\xad\xd4\xca\xf7\xe8Q\xbcY\xa3\x9f\xd4\x9d\x8ar\xcf\x8b\xe5\xa4\x01po\xf7\x18\xaaN0\xbf^\xbe\x15 ^~\xc3\x8c\x86\xdbe',
        "rounds": 10, # DEFAULT toString
},
"aes_counter": b'o\xb5\x14\xa0\x04Z\xfcp\x93,\xba\x94\xc9s\xf6\x97',
, True )
INFO:abouchet:done for pid 7655

ROOT CHILD - APP_DATA IS NOT HERE ANYMORE - but we found remains ( of key aes_ctx ~30bits)
still same mappings used...
$ sudo python abouchet.py --string refresh 7572 ctypes_openssh.ssh_aes_ctr_ctx 0xb8595970
INFO:root:Attach process 7572
INFO:root:Attach <PtraceProcess #7572> to debugger
INFO:root:Set <PtraceProcess #7572> options to 1
INFO:abouchet:found instance <class 'ctypes_openssh.ssh_aes_ctr_ctx'> @ 0xb8595970
(  # <ctypes_openssh.ssh_aes_ctr_ctx object at 0xb7414104>
"aes_ctx": {             # <ctypes_openssl.AES_KEY object at 0xb74141dc>
        "rd_key": b"\xa0[Y\xb8 \x00\x00\x00!\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00G]t\x8c \x00\x00\x00\t\x01\x00\x00v\xfe\xb9\x8aF.\x91\x90c\xfc\x0f\x8b\xc9\xaf\x97\x14j\t\xab(\x9f\x93<\x1d\xc8\xbc\xae\x06\xa3\n,\x01o\t\x034\x01\xee\x04:d\x8aH\xa1\xd4\x12\xbc\xb9\xef\xd1\x90\x85\x16\xd6\xbbN\xaf\x14\xf5\xda_\x15o\x9a\xe4i\rZ'\xcf\x07\xd8\xdaWQ\xe3\xb3\xe3\xa0\x13+\x19\xd5m\xe0}\xa7\xc1\x96\xfaa\xd4\xc1!.F*\x9d\xf5\xec\x9f\xa9\xa8\x82\xfdO@\xd5\xbc\x07>\xe2\xfbl\x99\x1f\xbc\xad\xa5\xb9C\x1dF\x9dW\xb9\xb4kp\x88\xa3D\xee\x18N\xe4K\xb8\xba\xd0\x0b\xa3a\x99i\xa1w0\xc1\xe4\x91I@,N.\xc2.\xcb\x0c\x9f\x13\xc9\xb6\x9c\xf3\xa37\x9e\x14\xad\xd4\xca\xf7\xe8Q\xbcY\xa3\x9f\xd4\x9d\x8ar\xcf\x8b\xe5\xa4\x01po\xf7\x18\xaaN0\xbf^\xbe\x15 ^~\xc3\x8c\x86\xdbe",
        "rounds": 2059157974, # DEFAULT toString
},
"aes_counter": b'\xa0a\xdeO\xf5\xf8\x8deS\xdb\xe0\xaah\xf8\xfe4',
, True )

# set args abouchet.py --string refresh 7655 ctypes_openssh.session_state 0xb85963a8

### current problem on TCP retransmission
case 1:

DEBUG:socket.scapy:seqnum 672 -     4018781477 len: 48 outbound: 672 bytes/14 packets max_seq:4018781477 expected_seq:4018781477
DEBUG:socket.scapy:seqnum 720 -     4018781525 len: 48 outbound: 720 bytes/15 packets max_seq:4018781525 expected_seq:4018781525
DEBUG:socket.scapy:seqnum 672 -     4018781477 len: 96 outbound: 768 bytes/16 packets max_seq:4018781573 expected_seq:4018781573
WARNING:socket.scapy:We just received 4018781477 when we already processed 4018781573
packet 3 = packet 1 + packet 2   => ignore it


case2:
DEBUG:socket.scapy:Queuing packet seq: 1494689839 len: 160 inbound: 398912 bytes/559 packets max_seq:1494689471 expected_seq:1494689727
DEBUG:socket.scapy:Queuing packet seq: 1494689999 len: 80 inbound: 398912 bytes/559 packets max_seq:1494689471 expected_seq:1494689727

explaination : missing packet in pcap capture. bad scapy.

2 solutions:
a) ask for transmission. hard. get a better packet capture ?
b) drop packet, and ignore the len/AES_BLOCK_SIZE block in decrypt. hard2. means we probably have to 'refresh key' as it would be easier. 












